~~在学习Cache的过程中，相信有不少人会对字、字节、字长、块等概念绕晕，如：有一Cache系统，字长为32位，主存容量为64字节，Cache的容量为1字×8块...~~
~~因此将尝试用动画的方式介绍Cache中的内存模型和三种映射方式，希望能给大家留下直观的印象。~~

（字节与地址空间，字与地址计算，寻址的双重视角）

## 配音稿

### 原版：

今天让我们来谈谈内存。我们可以用不同的视角来看待，对装机人来说，是这样的内存条；对于操作系统视角，可以是虚拟内存；对于硬件的视角，可以视为物理内存；而如果要深入到电路，就是这样的电路图。当然这些只是简单的分类，实际中可以存在更多不同的视角。今天让我们把目光放在物理内存上，首先将会介绍基础的内存模型，接着会介绍字节与地址空间的概念，然后介绍一下地址的计算和字的概念，最后会带来寻址的双重视角介绍。

现在让我们聚焦于物理内存的模型。 目前有一个cpu和一个硬盘ssd，要把数据从ssd中读取到cpu，但因为cpu计算速度和ssd速度相差太大，就像是xxx，就需要引入xxx，对应于计算机中就是内存。例如，在启动游戏时，就会先将一部分的数据加载到内存中，从而减少了加载的时间。在读取数据时，cpu就会通过地址访问内存，而内存将数据返回给cpu。 在写入数据时，cpu会将地址和数据一起交给内存。我们可以发现，地址和数据是内存中最为重要的概念。

通常我们能够看到这样的内存模型，就像是快递柜一样，可以给它编上号，这个号码就是地址，而里面存的东西就是数据。在很多教科书中，都将内存视为字节数组，换个说法，就是按字节编址，此时可以将一行视作一个字节。接着我们来看一下什么是字节，深入其中一行，里面有八个位，位是计算机中最小的存储单位，其值只有零和一。一字节等于八位，这是个很重要的概念。我们可以看到，一个位能够访问两个地址，而如果是两个位，先在前面添加上零，再补充一开头的情况，这样我们就得到了四个地址。那如果是三个位呢，其实也一样，一后面的两个位和上面零开头的的保持一致，这样我们就得到了八个地址。 好了现在让我们整理一下，并推出通用的表达形式。再分别转换为数学的表达形式，不妨再将其进行转换为对数表达形式，并画出其函数图像，可以看到函数上的点，分别和表达式和左边方框内的内容保持一致。

接下去我们关注一个64字节大小的内存。按字节编址，我们可以把一行看作是一个字节，那么这个模型就有64行，我们使用之前得到的表达式，就能计算出需要6位来访问该内存。在这里给出进制转换的表格进行参考。将这六位的数字转换为十进制，展开表达式进行计算，计算得到的结果就是该模型的地址。不妨改变一下其中的一位，就能够得到其他的地址。 在了解了地址计算之后，我们来看看字的概念。字并没有固定的大小，我们可以让1个字等于1个字节，这样的话该模型的一行就是一个字，和上面的一样，需要通过六位来访问所有的地址。而现在如果另一个字等于四个字节，那就相当于四行为一个字，我们标上序号，可以计算出需要四位来访问这十六个序号，同样可以展开计算出十进制，从而得到访问的序号。现在不妨将这四行压成一行，就像这样，此时依然是64个字节大的内存，但其中的一格代表了字节，而此时的一行就代表一个字，里面是32个位。不知道大家有没有想过，6位能够访问64个格子，4位能够访问16行，那么相差的2位能够做些什么呢？

重新整理一下目前的情报。内存大小是64个字节，使用这一个模型，其中的1格为1个字节，需要6位来访问64个格子，一行包括了4个字节，需要使用4位来访问16行。仔细看下每一行的内存，一共四列，那使用2位不就正好能够访问这四列吗？我们可以来验证一下，在模型上面标上二进制表达形式。首先计算6位的结果，对应的就是其中的一个格子，再计算4位的结果，对应的是模型的一行，最后直接可以将2位的对应到模型上面标出的表达式中，我们就能发现，通过6位访问，分别通过4位和2位访问，结果是一致的，可以转换一下其中的数字再来验证。目前变换的只是2位里的数字，而其实变换4位里的数字也是一样的。现在如果想要访问25号的地址，我们可以反推得到6位的表达式，其对应的行和列也能得到改地址，实际上这六位的数字和4位加上2位的数字始终是一致的，不同的只是我们如何去理解其中的位数。

这种思考方式在内存中并不少见，不只是在缓存的映射方式中能找到，在虚拟内存中同样也有类似的思想。

希望能够给大家带来启发，谢谢大家的观看。



### GPT：

让我们来深入探讨一下“内存”。内存可以从多个维度来理解。装机人看到的，是实实在在的内存条；在操作系统的领域，我们更多谈及的是“虚拟内存”；而从硬件角度，它通常被称为“物理内存”；若再深入到电路层面，我们可以看到内存的最小单元电路图。当然，这些仅是简单的分类，在实际应用中，其维度远不止这些。现在让我们把目光放在物理内存上。首先会介绍基本的内存模型，然后了解“字节”与“地址空间”的定义，接下来会深入到地址的计算及“字”的概念，最后将从双重角度详解寻址技术。

现在让我们聚焦于物理内存的模型。目前有一个CPU和一个硬盘SSD。想象一下，要把数据从SSD中读取到CPU，但由于CPU的计算速度和SSD的读取速度相差悬殊，就像是**跑车与自行车的速度差异**，此时我们需要一个中间介质来缓解这种速度差异，这个中间介质就像是**一个高速的中继站**。在计算机中，这个中继站就是内存。例如，当我们启动一个大型游戏时，系统会先将游戏的关键数据加载到内存中，这样可以大大减少游戏的加载时间，为玩家带来更流畅的体验。当CPU需要读取数据时，它会通过特定的地址访问内存，而内存会将对应地址的数据迅速返回给CPU。同样地，在写入数据时，CPU会将目标地址和待写入的数据一同交给内存。从这我们可以看出，地址和数据无疑是内存操作中两个最为核心的概念。

内存的模型通常被比喻为一个巨大的快递柜，每个格子都有唯一的编号，这就是我们说的“地址”。而格子里放置的物品，代表了“数据”。许多教科书将内存形容为一个字节数组，或者说，是一个按字节进行编址的存储空间。在这个空间中，每一行可以看作是一个字节。那么，什么是字节呢？如果我们放大观察一个字节，会发现它由八个“位”组成。在计算机科学中，位是最基本的存储单元，只能为0或1。这样，一字节就等于八位，记住这一点非常关键。现在，考虑位的组合。一个位能表示两种状态，即0和1，因此有两个可能的地址。两个位可以表示的地址为零零,零一, 一零, 一一，共四个地址。而三个位则有八种组合方式，从零零零到一一一，代表八个不同的地址。好了现在让我们整理一下，并推出通用的表达形式。分别转换为数学的表达形式，不妨再将其进行转换为对数表达形式。当我们画出该函数的图像时，你会发现图上的点与先前提及的数学表达形式和左边方框内的内容相一致，这为我们提供了一个直观的方法来理解位与地址之间的关系。

接下去，让我们看看一个64字节的内存。当我们按字节编址，每一行代表一个字节，这意味着我们有64行。使用之前的表达式，我们可以确定需要6位来唯一标识这64个地址。在这里提供一个进制转换表供参考。当你将这6位二进制数转换为十进制时，结果就是你要访问的内存地址。而仅仅改变其中一位，你就可以得到不同的地址。

那么，什么是“字”呢？字的大小是可变的。例如，如果一个字等于一个字节，那么这个64字节的模型就有64个字，每个都需要6位来访问。但如果一个字等于四个字节，那它的行数就会减少，仅需要4位来访问这些行。为了简化表示，我们可以将每四行压缩成一行。尽管总体内存仍为64字节，但此时每行代表4个字节或32位。



你可能会好奇，6位能够访问64个地址，而4位只能访问16个，那么这两者之间的2位差异意味着什么呢？

再次整理一下：一个64字节的内存有64个单独的格子，每个需要6位来访问。每行有4列，只需2位即可访问。这就意味着，我们可以用4位来决定行，而2位来决定列。事实上，这种6位的组合方式和分别使用4位和2位的组合方式得到的结果是完全一致的。

为了进一步说明，考虑你希望访问第25号地址。通过6位的组合，或者分别使用4位和2位，你都能得到相同的地址。这种思考方式并不少见，实际上在诸如缓存映射或虚拟内存的领域中都有应用。希望这能为你带来一些启示。感谢你的关注！



### 综合：

今天让我们来谈谈内存。我们可以用不同的视角来看待。装机人看到的，是这样的内存条。在操作系统的领域，我们更多谈及的是“虚拟内存”。而从硬件角度，它通常被称为“物理内存”。若再深入到电路层面，我们可以看到内存的最小单元电路图。

当然，这些仅是简单的分类，在实际应用中，其维度远不止这些。今天，我们将重点关注物理内存。

现在让我们聚焦于物理内存的模型。目前有一个处理器和一个固态硬盘。由于处理器的计算速度和硬盘的读取速度相差悬殊，就需要通过内存来缓解这种速度差异。例如当我们启动一个大型游戏时，系统会先将游戏的关键数据加载到内存中，这样可以大大减少游戏的加载时间。当处理器需要读取数据时，它会通过特定的地址访问内存，而内存会将对应地址的数据返回给处理器。同样地，在写入数据时，处理器会将目标地址和待写入的数据一同交给内存。从中我们可以看出，地址和数据无疑是内存操作中两个最为核心的概念。





~~在学习计算机存储系统的时候，相信有不少人会对字、字节、字长、块等概念绕晕，~~

~~我将探讨计算机物理内存的简化模型，重点介绍基础概念如位、字、字节和寻址~~



## 思路

“The formulation of the problem is often more essential than its solution, which may be merely a matter of mathematical or experimental skill.”
― Albert Einstein

首先，我们来明确问题到底是什么，在这里只会关注最简的架构（渲染出cpu和内存）。cpu给出一段地址，通过这段地址获取到对应的数据。此时加入缓存（渲染Cache），如果能在缓存中找到数据，就直接返回该数据。如果在缓存中找不到该数据，就会去访问内存，并将对应的数据从内存中拷贝到缓存中，再返回对应的数据。

接下去我们进一步关注内存模型，内存由地址和数据两部分组成，通常地址来获取数据，可以将其简单理解为一个数组。在这里，我们假设内存的大小为64字节，按字节编址。此时就需要引入字的概念，通常将内存的一个行称为字，按字节编址即一个字等于一个字节，也就是说，内存的一行就是一个字节。内存大小为64字节，代表了共有内存共有64行，也就是64个字。1个位可以访问2个字，2位可以访问4个字，那么要访问64个字，就需要6位，称之为物理地址。

接下去开始聚焦于内存模型，希望展示的是，左上角是文字区域，右边是内存模型。

 现代个人计算机(PC)的存储器编址，一般是以字节为单位的，称之为*按字节编址*，因此字节一般也是存储器的最小存取单元以及处理器的最小寻址单位。首先是字节数组，8行。接着引出需要3位来访问（既然存储的是位，那么门牌号也可以用位来表示）

内存模型采用64B，首先是一行以字节为单位，共64行，然后引出log求访问的位数，需要6位来访问。然后引入字的概念，分别使用一字等于一字节和一字等于四字节，然后将64行的内存模型~~变换为~~**对比**16行每行4个字节的模型，之后再解释6位访问就需要做出区分。之后引入块的概念，在这里约定一块等于四个字，引出cache的存储结构，以如何将块存储到cache的问题作结，这样的设计存在什么优化的地方

> ~~最后以一个问题结尾，统一度量衡~~
>
> 以及可以使用两种颜色区别固定不变的概念和可变的概念

我们将深入探讨内存模型。内存可以被视为由地址空间和存储单元组成的结构。你可以将其理解为一个特殊的数组，其中我们使用地址来定位和访问内存中的数据。在此例中，我们设定内存的大小为64字节，并且采用字节编址。这里需要明确“字”的概念：通常情况下，一个存储单元在内存中代表一个字。当我们说按字节编址时，意味着一个字就是一个字节。因此，64字节的内存意味着我们有64个存储单元，或者说64个字。

为了后续解说的方便，将一个存储单元会统一称为字。

考虑二进制编码的特点，1位可以代表2个不同的状态。因此，为了表示或访问64个不同的存储单元，我们需要6位的地址。（根据不同的地址组合，访问不同的存储单元）

现在我们已经了解了内存的基本存储单元，但在缓存中，数据是如何存储的呢？是不是简单地一一对应地存储内存中的每一个存储单元？其实并不是这样的。为了使数据的存取更为高效，通常我们不是单独地存储或访问一个字，而是以一组连续的字进行操作。为此，我们引入了“块”或“block”的概念。在这里，一个块包含多个连续的字。比如，我们可以定义一个块为四个连续的字。这种设计的背后，其实基于了所谓的局部性原理，它意味着当程序访问某个数据时，它很可能在不久的将来再次访问这个数据，或者访问该数据附近的数据。有兴趣的同学可以去深入研究一下。

“The medium is the message.” - Marshall McLuhan


[Direct Memory Mapping](https://www.youtube.com/watch?v=V_QS1HzJ8Bc&t=2s)
[全相联映射、直接映射、组相连映射](https://blog.csdn.net/e2788666/article/details/125485606)
[Lecture 15. Memory Hierarchy, Fully Associative Caches](https://www.bilibili.com/video/BV1uS4y187Vi?p=15&vd_source=124fca8aee32fa43f3734e464910063c)