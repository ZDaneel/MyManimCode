## 引入

给出intel和m1架构的cpu，指出里面的缓存，说明其重要性，并展示视频讲解的内容

配音：大家好，今天让我们来谈谈缓存的基础知识。如果我们仔细地查看芯片的架构，就会发现里面都有缓存，不管是英特尔还是苹果的芯片，可见缓存的重要性。

这期视频将会聚焦于缓存，详细地介绍缓存的基础知识。我们的旅程将分为四个主要部分。

第一部分会介绍什么是缓存，它在计算机系统中扮演着怎样的角色?

第二部分解释块的概念，我们将了解块是如何在缓存中存储和管理数据的。

第三部分将从设计一个简单的缓存开始，逐步引导大家理解缓存的映射策略。

第四部分讲述缓存的结构，在这里将会和内存进行比较。

如果大家觉得有理解困难的地方，可以去看我之前讲物理内存的视频，包含这期视频的前置知识。

## 基础介绍

给出存储速度和容量的不可兼得、局部性原理的内容(标量通常指的是单个值的变量，如一个整数或浮点数)

之后在简单的cpu内存模型中引入缓存，并说明缓存命中和丢失

### 稿子

首先来看一下常见的访问内存的情况。坐标轴的x轴代表时间，y轴代表地址。如果是标量访问，例如下面的代码重复访问该标量，那么访问的情况就是这样的。而如果是数组访问，例如顺序访问数组的元素，其访问情况就应该是这样的。我们会发现访问并不是随机的，这其实背后体现的是局部性原理，空间局部性就是一个元素附近的元素很可能会被访问到，而时间局部性则是同一个元素很可能会被再次访问到。

接下来我们专注最简单的一个处理器内存模型，以读取数据为例，处理器会通过地址访问内存，内存将数据返回给处理器。离处理器越远的存储器容量越大，但是速度也会更慢，处理器和内存之间的速度差异依然很大，此时我们在这两者间引入缓存，从而增加了数据的读取效率。如果数据已经在缓存中，那么处理器就只需要通过地址访问缓存，这也称为缓存命中。而如果数据不在缓存中，缓存就会先从内存中获取相关的数据，然后再返回给处理器，这称为缓存丢失。

### GPT

让我们首先探索一下内存访问的常见模式。我们有一个坐标轴，其中x轴代表时间，而y轴代表地址。首先考虑一种标量访问的情况，就像下面这段代码，它重复地访问同一个标量。在这种情况下，内存访问的模式会呈现出这样的特点。而另一方面，如果我们考虑数组访问——比如顺序地访问数组中的每个元素，那么其访问模式将呈现出另一种趋势。

观察这两种不同的访问情况，我们可以发现，内存访问并非是完全随机的。这其实是局部性原理的一个生动体现。局部性原理可以分为两类：一是空间局部性，即一个元素周围的元素很有可能被接下来访问到；二是时间局部性，即一个元素一旦被访问，很可能在短时间内再次被访问。局部性原理至关重要，确保了缓存能够有效运作。

接着让我们聚焦于一个最基础的处理器内存模型。当处理器需要读取数据时，它通过一个特定的地址访问内存。内存响应这一请求，将数据送回处理器。然而，存储器的一个有趣特性是，它离处理器越远，容量通常越大，但速度却越慢。这种速度的差异在处理器和内存之间依然很明显。

为了解决这一速度差异带来的挑战，我们在处理器和内存之间引入了一个强大的中间者——缓存。缓存的引入显著提升了数据读取的效率。当处理器寻找的数据恰好在缓存中时，这称为“缓存命中”，处理器可以迅速通过地址访问缓存中的数据。相反，如果所需数据不在缓存中，我们称这种情况为“缓存丢失”。此时，缓存必须先从内存中获取相应的数据，然后再将它返回。

通过这种方式，缓存成为了处理器和内存之间高效交换数据的关键。它既缩短了数据访问的时间，又保持了系统整体的高效运作。这就是我们今天要深入探讨的神秘而强大的缓存的基本原理。

## 块的概念

通过给出不同的简化模型，引入块的概念（解释为什么块对于缓存设计至关重要）

我们来讲问题进行简化，下面给出最简单的一个cpu内存模型，以读取数据为例，cpu给出一个地址，内存返回对应存储位置的数据。虽然内存的引入。

### 稿子

接下来我们将会关注块的概念。首先来看一下这个内存模型，其大小为64字节。如果按字节编址，其中的一个格子代表一个字节，共需要6个位来访问64个格子。如果是按字编址，此处令一个字等于四个字节，那么其中的一行就代表一个字，共需要4位来访问这16行。

块的概念和字其实本质上是差不多的，我们可以先另一个块等于一个字，此时内存的一行就表示一个块。此时给出一个四行的缓存模型，缓存的每一行都等于一个块，那么此时内存中的一个块就能够放入到缓存的某一行中，就如现在展示的这样。

我们再另一个块等于四个字，此时四个内存行才是一个块，我们将其高亮并标上序号，此时给出一个两行的缓存模型，缓存行是永远等于一个块的，那么此时就会出现这样的情况，四个内存行组成的块能够放入到缓存的某一行中。

### GPT

接下来，我们将深入探索“块”这一核心概念。首先，让我们来观察这个64字节的内存模型。在按字节编址的情况下，每个小格子代表一个字节，因此我们需要6位来访问这64个格子。如果我们按字来编址，假设一个字等同于四个字节，那么每一行就代表一个字，此时只需4位便可访问这16行。

实际上，块的概念与字的概念在本质上是相似的。比如，我们可以设定一个块等同于一个字，这样内存的一行就相当于一个块。现在，让我们来看一个四行的缓存模型。在这个模型中，缓存的每一行都对应一个块，因此一个内存块就可以直接放入缓存的任一行，正如您在屏幕上所见。

那么，如果我们让一个块等于四个字呢？这种情况下，四行内存才组成一个完整的块。我们将这四行高亮显示并进行编号，以此来展示它们如何组成一个块。此时展示一个两航的缓存模型，缓存航始终等于一个块的大小。在这种情况下，由四航内存组成的块能够被整体存放进缓存的一航中。

## 缓存地址和存储

将内存和缓存进行对比，说明其都有地址和存储空间

但访问元素的方式存在区别，缓存地址会用到内存地址的内容

### 稿子

接下去让我们比较一下内存和缓存的结构。地址有着存储空间和其对应的地址，通过地址就可以访问到存储空间中对应的数据。缓存也有存储空间，但与内存不同的是，缓存需要的是控制信息，例如通过有效位表示该行是否已经有数据。控制信息和存储空间一起被称为缓存槽。

我们再来看一下内存和缓存的地址结构，缓存的地址结构的一部分实际上就是内存的地址，之后会讲到对内存地址的重新理解，而缓存的访问正依赖于这样的重新理解。缓存地址结构的另一部分是其他控制信息，如果我们添加一个表示脏数据的位，其对应的就在控制信息中。

此外 还可以有其他的标志信息，如一个表示脏数据的位。

我们来看一下内存的地址结构，首先能够以块为单位理解地址，分为块索引和块内偏移。而缓存能够对内存地址重新进行理解，以组相联映射为例，分为标记、组索引和偏移。其中的标记正是缓存中的控制信息。

此时我们能够计算出缓存的总容量，就是缓存槽的大小乘以缓存总航数，一个槽中包含了有效位、标志位、标记和块容量，在计算时，关键是要保持单位的一致性。而缓存还有存储容量，即一行的块容量乘以缓存总行数，在这个情况下，就会有缓存地址的概念出现，由行索引和行内偏移组成，其本质和以块为单位对内存地址的理解是一致的。因此我们可以通过存储容量计算出缓存的地址位数。让我们用一个具体的例子来阐述。一行的块容量是两个字，缓存共有四行，那么一共就是八个字，对应的是三个位。因为缓存行数是四，那么行索引就是二位，块容量是两个字，那么行内偏移就是一位，完全相符合。

### GPT

接下去让我们看一下内存与缓存的结构差异。首先，内存的结构相对直观，它包含存储空间及其对应的地址。通过这些地址，我们可以直接访问存储空间中的特定数据。而缓存同样具有存储空间，但与内存不同，缓存还需要的是控制信息，如有效位用于标示该行数据是否有效。这些控制信息与存储数据共同组成了所谓的“缓存槽”。

进一步来看，内存和缓存的地址结构也有所不同。缓存地址的一部分实际来源于内存地址，这种地址的重新解释是理解缓存访问机制的关键，也是我们之后会关注的重点。而缓存地址的另一部分则涵盖了额外的控制信息

此外还可能会有标记“赃数据”的位，这些都是控制信息的一部分，对缓存的高效运行至关重要。

在设计缓存时，我们首先需要考虑其总容量。这可以通过计算缓存槽的大小与缓存行数的乘积得出。一个缓存槽通常包括有效位、标记位和块容量。在计算时，关键是要保持这些单位的一致性。

缓存的存储容量是另一个关键概念。它指的是单个缓存行的块容量与缓存行总数的乘积。例如，如果一个块容量为两个字，并且缓存共有四行，那么总存储容量就是八个字。这就引出了缓存地址的概念，由行索引和行内偏移组成。这与我们按块为单位理解内存地址的方式是一致的。

让我们用一个具体的例子来阐述。假设缓存的行数为四，那么行索引需要两位来表示。而如果每行的块容量是两个字，行内偏移就需要一位来表示。这样，整个缓存地址的位数就是三位，完全与我们之前的理解相符。

## 设计一个缓存

一块等于二字、一字等于四字节设计，这样64B就有8个块，那缓存设计为4个槽，就是8个块放入4个槽的问题。
如果要找到字，块内是二字那就需要一位

逐渐给出offset、index和tag，说明我们可以这样来访问一个缓存

### 稿子

接着就让我们尝试自己设计一个缓存。首先还是请出我们的老朋友，这个64个格子的内存模型，下面只给出关键的信息。我们令一个块等于两个字，因此两个内存行就是一个块，后面出现的内存模型将会以块为基础单位。让我们使用一个四行的缓存模型，我们都知道，缓存行等于一个块，那其中就包括了两个字，也就是八个字节。

缓存的目的是通过内存地址返回给处理器数据，而处理器是不知道块的存在，因此我们需要从块中找到对应的数据。如果此时是按字节编址，那么访问这八个字节，就需要三个位，我们称之为偏移量。而如果是按字编址，那么访问的就是两个字，只需要一个位。

接着我们可以看到这是一个四行的缓存，为了找到其中一行的数据，不就需要通过两位来访问这四行吗？我们讲其称之为索引。

这时候我们再请出以块为一行的内存模型，八个内存块放入四个缓存行，那必然会出现两个内存块放到同一个缓存行的情况，那么最后剩下的这一位就用于解决一个缓存行发生冲突的问题。

但是如果此时又有一个内存块要放入到这同一个缓存行呢？靠一个位不就无法区分这三个内存块了吗？而为了解决这一个冲突问题，我们就需要使用到映射策略。

既然一个标记位只能区分两个内存块，那么我们就指定内存块存储到位置。直接映射的思想就如箭头所示。这样一来，一个缓存行就只会有两个内存块存入，符合我们之前的设计。直接映射的优点便是硬件设计容易，因为有索引的存在，查询速度也很快。但缺点是一个缓存行只能区分两个内存块，会导致严重的冲突问题，从而降低效率。

那我们就让每个缓存行区分更多的内存块，直接区分全部内存块会怎么样？这是全相联映射的思想。如箭头所示，一个内存块可以放入任意的缓存行，每一个内存块都是如此。此时我们需要修改对内存的理解，此时只需要通过标记就能访问到对应的缓存行，因此不再需要索引，只需要将其都改为标记，而3位的标记，也对应着一个缓存行能够区分的块数。其优点很明显，冲突会特别少，但由于没有了索引，每次访问都需要和所有的标记进行比较，查询速度慢，并且硬件设计也会很复杂。

因此我们需要一个折衷的策略，这就是组相联映射。组的概念和块、字本质是一样的，如果一个组中有一个块，即一个缓存行，我们就称为一路组相联，就像现在没有区分的一样。而如果一个组里面有两个块，即两个缓存行，就称为二路组相联，我们可以将其高亮表示出来。那此时我们可以通过一个位来访问这两个组，有些地方也将其称为组索引。此时的标记是两位，我们来验证一下，此时的映射情况如箭头所示，内存块需要放入组中，而在组中可以任意放置于其中一行，这和全相联一样，因此我们只需要通过标记来在组里面访问。每个内存块都指定放入对应的组里面，这是直接相联的思路。而此时每个缓存行都有四个箭头，和两位的标记能区分的内存块一致。一开始会不太好理解，大家可以花点时间仔细体会一下，组相联映射是直接相联和全相联的折衷，其冲突、查询速度、硬件设计复杂度都能达到平衡。

### GPT

接下来，让我们一起动手设计一个缓存。首先，再次回顾一下我们的64格内存模型。我们将一个块定义为两个字，这样两行内存就构成了一个块。现在的内存模型将以块为基本单位。我们使用一个四行的缓存模型。众所周知，缓存的每一行都对应一个块，包含了两个字，即八个字节。

处理器访问缓存的目的是快速获取内存地址中的数据。然而，处理器并不直接知晓块的存在。因此，我们需要从一个块中定位到具体的数据。如果采用按字节编址的方式，访问这八个字节需要三位作为偏移量。而如果按字编址，只需一个位来访问两个字。

接下来，观察这个四航的缓存。为了定位到其中一航的数据，我们需要通过两位来访问这四航，可以将其称之为索引。

现在，让我们引入以块为单位的内存模型。当八个内存块对应到四个缓存行时，必然会有两个内存块映射到同一缓存行。

这最后一位就是为了解决这种冲突而设的，将其称为标记。

但如果又有新的内存块要映射到这个已满的缓存行呢？单靠一位无法区分三个不同的内存块。为了解决这一问题，我们需要引入不同的映射策略。

直接映射的思想简单明了，如箭头所示，一个缓存行只对应两个内存块，这符合我们的初衷。直接映射的优点是硬件设计简单，索引的存在使得查询速度快。但缺点在于一个缓存行的冲突概率较高，可能会影响效率。

接着，让我们考虑一下，如果让一个缓存行对应所有的内存块会怎样？这正是全相联映射的理念。如箭头所指，任一内存块都可映射到任一缓存行。此时我们需要重新理解内存地址，所有的内存地址将通过标记来定位缓存行，无需索引。

而三位的标记，也对应着一个缓存行能够区分的块数。全相联映射的优势在于冲突减少，但查询速度较慢，硬件设计也较为复杂。

最后，我们寻求一个折中方案，这就是组相联映射。组的概念本质上与块、字相似。单路组相联实际上是没有区分的状态。如果一个组包含两个块，即两个缓存行，我们称之为二路组相联。这样，我们可以通过一位组索引来访问这两个组。

每个内存块被指定到特定的组中，类似于直接映射。而在组内的定位则采用全相联的方式，通过标记来访问。组相联映射巧妙地平衡了冲突频率、查询速度和硬件设计的复杂度，是一种高效的映射策略。

## 三种映射简介

从我们的设计引出三种映射，只是简单介绍

在结构上的不同，就只讲述最基础部分，而不需要关注具体的读写数据

### 稿子

最后我们来看一下三种映射策略的总结，通过一步一步的推导，希望能够让大家对缓存留下一个直观的印象，其实缓存的映射策略并不是特别复杂，只是对内存地址进行理解、分解、再构造。计算机中并没有什么魔法，有的只是来自人类的精妙设计。谢谢大家的观看！

### GPT

最后，让我们对三种缓存映射策略做一个简要总结。通过这一步步的推导，我希望能够帮助大家形成一个关于缓存的直观理解。实际上，缓存的映射策略并没有想象中那么复杂，核心上是对内存地址的一种巧妙的解析、分解与重新组合。在计算机世界里，没有所谓的魔法，存在的只是人类智慧的结晶。感谢大家的聆听与观看！




为了保证视频内容的流畅性和易理解性，在某些部分简化了细节描述。如果对Cache的深入学习感兴趣，欢迎访问下方链接查看本视频的主要参考资料。这些资料将会提供更全面和详尽的信息。

仿真平台Logisim上用硬件实现Cache：https://www.bilibili.com/video/BV1y741177jV/?p=42

咖喱味英语，但质量很高：https://www.youtube.com/watch?v=Ez_kyBS-y5w&list=PLBlnK6fEyqRgLLlzdgiTUKULKJPYc0A4q&index=7

UCB的CS 61C：https://www.bilibili.com/video/BV1uS4y187Vi?p=15

Erik佬讲Cache-Oblivious（还在艰难啃ing）：https://www.bilibili.com/video/BV1ie41197nH/?p=7