## 前言

上一期的视频中，讲解了cache的基础概念，包括块的概念、映射方式和缓存结构。但这些还只是零件，如果想要理解缓存运作的具体流程还是不够的，因此在这期视频里，将会通过对三种映射具体运行流程的展示，希望能够让大家对缓存的运作机理有更加形象和直观的理解。

> 在上一期视频中，我们探讨了缓存的基本概念，涉及到了块的概念、缓存的映射方式和结构。这些是理解缓存如何运作的基础部件。但要想深入理解缓存的工作原理，仅仅了解这些概念还远远不够。
>
> 因此，在这一期的视频里，我们会通过对三种映射方式的具体运行流程的详细展示，希望能帮助大家对缓存的运作机制有一个更加生动和直观的认识。

## 直接相联映射

- 规定块的大小、回顾如何进行映射、展示对内存的理解
  - 直接相联在左上角
  - 下面方框里表明字和块的大小
- 通过一个序列展示可能发生的情形

稿子：首先让我们回顾一下直接映射，和之前保持一致，我们使用按字编址的模型，规定一个字等于四字节，一个块等于两个字。对应的是这样的内存模型，其中每一行代表一个块，每行内的每个格子表示一个字，为了方便区分，数据是用D1到D16表示的。其对应的是四位的地址，其中包括三位块索引和一位块内偏移，这样的划分方便以块为单位进行操作。这是我们将使用的缓存模型，共有四个缓存行，每行都有有效位、标记位和对应的缓存数据，直接映射对内存地址的划分是一个标记位、两位索引和一位的块内偏移。这是直接映射对应的可能的映射情况。我们给出如下的访问地址序列。

一开始的时候，缓存是空的，首先处理0，我们将0的二进制表示进行解析。通过索引可以找到对应的缓存行，此时的标记为空，有效位为0，代表没有数据，此时就会从内存中读取对应的数据。从内存中找到对应的内存块，将其写入缓存中的对应位置。同时，更新缓存行的标记位和有效位。此时，就能够通过块内偏移找到对应的数据。

接着我们处理下一个地址，此时的索引是1，就会找到的缓存行，之后就会使用同样的方式写入、更新。

当处理地址3时，此时的索引同样是1，标记位和当前缓存行的一致，并且有效位是1，这就代表了缓存命中，我们就能直接通过块内偏移在缓存内找到对应的数据。

此时再处理地址8，其索引能够找到序号0的缓存行，此时虽然有效位是1，但是标记却不同，说明此时发生了冲突，就需要进行替换。而直接映射的替换最为简单，因为每个内存块都有对应映射的缓存行，我们找到需要进行替换的内存块，就能够将新的数据写入到缓存行中。此时我们可以看一个小技巧，我们可以通过地址值，进行一个取余操作，其中的4代表缓存的总行数，通过这样的计算就能找到内存块映射到的缓存行。我们回到替换操作中，将数据写入缓存数据，同时更新标记位，之后就能够通过块内偏移找到对应的数据。

> 让我们以一种更流畅和引人入胜的方式回顾直接映射缓存的概念。为了保持与之前讨论的模型一致，我们继续采用按字节寻址的方式，这里我们定义一个字为四个字节，一个缓存块包含两个字。在这个内存模型中，每一行代表一个缓存块，而行内的每个单元格则代表一个字。为了便于说明，我们用D1到D16来表示不同的数据。地址由四位组成，包括三位用于块索引和一位用于块内偏移，这样的设计使得以块为单位的操作变得更加直观。
>
> 我们所使用的缓存模型包含四个缓存行，每一行都配备了有效位、标记位以及缓存数据。在直接映射策略中，内存地址被划分为一个标记位、两位索引和一位块内偏移。接下来，让我们通过一系列访问地址来探索这种映射策略的实际应用。
>
> 初始时，缓存为空。首先处理地址0，我们将其二进制形式解析出来。通过索引，我们定位到相应的缓存行，此时发现标记位为空，有效位为0，意味着缓存中没有数据。因此，我们会从内存中读取相应的缓存块并写入缓存的对应位置，同时更新缓存行的标记位和有效位。这样，就可以通过块内偏移快速定位到所需的数据。
>
> 接下来处理地址1，通过索引我们找到相应的缓存行，并采用相同的方法进行数据写入和更新。
>
> 当地址为3时，由于索引相同，且标记位与当前缓存行一致，有效位为1，这表示发生了缓存命中。我们便可以直接通过块内偏移在缓存中找到所需数据。
>
> 再来看地址8的处理，其索引将我们引导至编号为0的缓存行。尽管有效位为1，但标记位不匹配，这表明发生了冲突，需要替换。直接映射的替换操作非常直接，通过定位到需替换的内存块，我们便可以将新数据写入缓存行。此处有个小窍门：通过对地址进行取余操作（以缓存行总数4为模），我们可以轻松计算出内存块映射到的缓存行。完成替换后，我们更新标记位，并可以通过块内偏移快速访问到数据。
>
> 通过这个过程，我们不仅复习了直接映射的基本原理，还通过具体示例深入了解了其操作细节，使得这一概念更加清晰和容易理解。

## 全相联映射1

- 首先回顾
- 然后序列
- 出现问题，即如何替换

稿子：接下去，我们来看一下全相联映射的情况。模型和直接映射基本一致，但此时缓存对内存地址的划分有所不同，全相联映射中没有索引，只有三位的标记。

首先我们使用同样的地址序列，此时没有了索引，需要做的是，将地址的标记和缓存中每行的标记都进行比较，此时没有标记，那一定找不到对应的缓存行。就需要从内存中读取对应的内存块，此时过程和直接相联几乎一致，不过在全相联映射中，内存块可以被映射到任意的缓存行，写入数据的同时，也要更新标记和有效位，这时候就能够通过偏移找到对应的数据。接着对于地址2，进行同样的操作。对于地址3，继续讲标记位和缓存内的所有标记进行比较，此时就能找到对应的标记，并且有效位是1，代表了缓存命中，就能够直接找到数据。对于地址8，在直接映射中就发烧了冲突，但对于全相联映射，这时候缓存内没有相对应的标记，那就需要从内存中读取数据到空的缓存行。对于地址11，也是同样的操作，这时候才将缓存全部填满。我们再来看看对地址13的处理，这时候没能够从缓存中找到对应的标记，就需要进行替换，但是，问题就来了，我们替换哪一行呢？

> 接下来，让我们深入探讨全相联映射的机制。与直接映射在结构上基本相似，全相联映射在处理内存地址时采取了不同的策略，它不使用索引，而是仅由三位的标记位构成。
>
> 首先，我们沿用相同的地址序列。由于缺少索引，我们需要将地址的标记位与缓存中每一行的标记位进行比较。在没有匹配的标记位的情况下，我们明知无法找到相应的缓存行，因此必须从内存中读取相应的内存块。这一过程与直接映射极为相似，不过在全相联映射中，任何内存块都可以映射到缓存中的任意一行。数据写入时，同时更新标记位和有效位，便可以通过块内偏移直接定位到所需数据。
>
> 继续处理地址2，采取相同的策略。而对于地址3，我们将其标记位与缓存中所有行的标记位进行比对。一旦找到匹配的标记，并且其有效位为1，就意味着发生了缓存命中，从而可以直接访问数据。而对于地址8，在直接映射场景中遇到了冲突，但在全相联映射下，由于缓存中不存在相应的标记，我们需要从内存中读取数据并将其存入一个空闲的缓存行中。对于地址11，操作过程相同，直到缓存被完全填满。
>
> 然而，当我们尝试处理地址13时，面临了一个问题：在未能在缓存中找到匹配的标记的情况下，我们需要进行替换。这时候，最大的挑战是决定替换哪一行缓存。这就引入了缓存替换策略的概念，如最近最少使用（LRU）策略、随机替换策略等，这些策略旨在优化缓存的使用效率，确保最有效地利用缓存资源。全相联映射的灵活性在于它允许任何内存块映射到任何缓存行，但这也意味着需要更智能的替换策略来决定最优的缓存行替换选择。

## 置换算法

- 首先提出置换算法
- 然后解释最近最久未访问LRU

它的原则是，如果一个数据最近没有被访问到，那么它将来被访问的几率也很小

LRU 策略（Mattson 等人，1970 年）是这些策略中最简单、应用最广泛的一种

LRU performs well when there is temporal locality of reference, that is, when data that was used recently is likely to be reused in the near future. But it performs poorly for two types of access patterns. First, it can be pessimal when the application’s working set size exceeds the cache size, leading to a phenomenon known as thrashing [Denning, 1968] (see Figure 3.1). Second, LRU performs poorly in the presence of scans because it caches more recently used scans at the expense of older lines that are more likely to be reused.

- 计数器和伪LRU

这是缓存替换策略，这个概念不仅仅是在硬件缓存中被研究，在虚拟内存的分页机制、缓存中间件等等场景里都有应用。有人对替换策略进行了分类，可以看到各种各样的策略，甚至还有专门的缓存替换策略比赛。这期视频的重点还是缓存和内存的交互，因此在这里只介绍最经典的一个策略，即最近最少使用。算法的原则是最近访问过的数据在不久的将来可能会被再次访问，那么需要替换的就是最近的，最少被使用的数据。首先介绍计数器法，计数器用于记录每行被访问的情况。由于LRU算法实现的开销过大，接着会介绍一种伪LRU的算法，使用二叉树来处理，能够节省不少的开销。只看文字自然是十分枯燥，我们直接通过动画来体会。

> 缓存替换策略是一个在多个领域内广泛研究的概念，不仅限于硬件缓存，还广泛应用于虚拟内存的分页机制、缓存中间件等场景。事实上，这个领域的探索如此深入，以至于存在专门针对缓存替换策略的比赛，展现了各种独特且高效的策略。在本期视频中，虽然我们的重点是缓存与内存的交互，但我还是想向大家介绍最为经典的缓存替换策略之一：最近最少使用（LRU）策略。
>
> LRU算法基于一个简单但强大的原则：如果一个数据最近被访问过，那么在不久的将来它很可能再次被访问。因此，当需要空间来存储新数据时，应该替换那些最近最少被使用的数据。我们首先探讨计数器法，这是一种通过记录每一行访问频次的方式来实现LRU算法。然而，由于LRU算法在实现时可能会带来相对较大的开销，我们接下来会介绍一种被称为伪LRU的算法。伪LRU算法通过使用二叉树的结构来简化过程，显著减少了实现LRU时所需的资源。
>
> 理解这些概念仅通过文字描述可能会显得有些枯燥。因此，我们将通过动画的形式，直观地展示这些缓存替换策略是如何工作的。通过动态可视化，我们可以更加深入地理解LRU及其变种策略在实际应用中的表现和效率，使这些看似抽象的概念变得生动和易于理解。

### 计数器法

首先是计数器法，我们对每个缓存行都添加一个计数器。接下去的操作会进行一定的简化。这个时候我们完成了数据写入和更新，因为我们访问到了这一行，就将这一行的计数器数值清零，而其他行的计数器都加一。之后的操作均是如此，如果是缓存命中，也会进行同样的处理。因此，计数器的数字越小，就代表了越是最近被访问过，那么，当缓存满了的时候，我们就应该替换计数器数字最大的那一行，而在替换之后，同样对当前行的计数器进行清零，以及其他所有行的计数器加一。

> 计数器法是实现最近最少使用（LRU）缓存替换策略的一种直观方式。在这种方法中，我们为每个缓存行配备一个计数器，通过这个计数器来追踪每行自上次被访问以来经过的时间。
>
> 简化接下来的操作流程，我们这样做：每当一个数据被写入或更新在某一缓存行时，因为该行被访问了，我们将该行的计数器重置为零，而其他未被访问的行的计数器则各自增加一。这样的操作确保了每一次访问都会被准确记录。在发生缓存命中时，即数据在缓存中被找到并访问，我们也采取相同的处理方法，即重置被命中行的计数器为零，并将所有其他行的计数器加一。
>
> 这种方法的关键在于：计数器的数值越小，表明该缓存行越是近期被访问过。因此，当缓存空间被完全占用时，我们应当选择计数器数值最大的那一行进行替换，因为它是最长时间未被访问的。替换操作完成后，我们对新写入的当前行的计数器进行清零，并对其他所有行的计数器进行加一操作，以保持追踪逻辑的一致性。
>
> 通过这种方式，计数器法为我们提供了一种相对简单且有效的手段来确定哪一缓存行是最近最少使用的，尽管它可能在实际应用中因为计数器更新的开销而受到限制。这种策略的实施确保了缓存利用的高效性，通过智能地选择替换哪个缓存行，来优化缓存的整体性能。

### 伪LRU法

接着我们再来看一下伪最近最少使用算法，其设计非常精妙，对于这样的树结构，节点的数值如果是1，就代表指向上面的节点，如果数值是0，就指向下面的节点，我们直接来看具体会如何变化。树结构会指向被访问的缓存行，此时我们需要指向第1行，就需要两个向上的箭头，那么就将根节点和上面节点的数值改为1。接下去需要指向第2行，就把上面节点的数值改为0即可。如果发生了缓存命中，就进行同样的操作，此时已经指向了这一行。这时候我们需要指向第3行，就需要改变根节点的数值。我们可以看到，就算是根节点的箭头发生了改变，上面节点的箭头并没有发生变化，这就代表着对访问情况的记录。同样对于第4行，改变下面节点的数值指向这一行即可。很显然，箭头的指向就代表了这一行相比之下最久被访问过，需要发生替换时，我们就从根节点开始进行逆转，就能够找到需要被替换的缓存行。由于并不是真正的最近最少使用算法，因此可能会出现一定的偏差，但是能够省下巨大的开销。实际上，对于硬件缓存，有研究发现，相比于随机替换，使用最近最少使用算法并不能提升太多的缓存命中率，却会带来了巨大的开销，感兴趣的大家可以自行去了解更多相关的内容。

> 伪最近最少使用（Pseudo-LRU）算法是一个巧妙设计的缓存替换策略，旨在近似实现最近最少使用（LRU）算法的效果，同时大幅度降低实施LRU所需的开销。这种算法利用了一种特殊的树结构，通过节点的值来指导缓存行的选择，其中节点的值如果是1，则表示选择上方的分支，如果值是0，则指向下方的分支。让我们通过一个具体的过程来理解这个算法是如何工作的。
>
> 考虑一个简化的场景，我们有一个树结构来管理缓存行的选择。当需要访问第1行缓存时，我们需要两个“向上”的指示，因此将根节点和其上方的子节点的值设为1。紧接着，如果我们需要访问第2行缓存，只需将上方子节点的值改为0。
>
> 当缓存命中发生时，即所需数据已经存在于缓存中，我们也执行相同的更新操作，以确保树结构反映最新的访问模式。如果随后我们需要访问第3行，这就需要改变根节点的值，从而指向一个新的方向。值得注意的是，即便根节点的指向发生了变化，上方子节点的指示可能保持不变，这种设计巧妙地记录了访问历史。
>
> 对于第4行的访问，我们通过改变下方子节点的值来指示这一新的访问。通过这种方式，箭头的指向隐喻地标示了哪些行是相对较久未被访问的，当需要进行缓存替换时，我们可以从根节点出发，逆向追踪到最合适的缓存行。
>
> 尽管伪LRU算法可能与真正的LRU算法相比存在一定偏差，因为它并不总能精确地标记出最久未被访问的行，但它在减少开销方面的优势是显著的。实际上，对于硬件缓存来说，有研究指出，相较于随机替换策略，真正的LRU算法在提升缓存命中率方面的效果并不显著，但会引入较大的开销。对此感兴趣的观众，我鼓励你们深入探索更多相关内容，以获得对缓存替换策略更全面的理解。

## 组相联映射

最后，我们就来到了组相联映射，在这里我们使用2路组相联映射，也就是每个组里只有2个缓存行，我们会使用计数器法，因为每个组里才是全相联映射的思路，额外需要注意计数器只会在组内进行变化。使用同样的地址序列，对于每个地址，首先会通过其组索引找到对应的组号，之后在组内比较标记，内存块写入和更新控制信息都和全相联映射保持一致，之后就能够找到数据。地址3首先找到组序号为1的组，然后再找到对应标记所在的行，就代表了缓存命中。对于地址8和11，其处理也是一样的。最后是地址13，在组序号为0的组里，找不到对应的标记，就会根据此时最大的计数器值找到需要替换的行，就能够得到我们想要的数据。

通过这些动画，希望大家能够直观体会到三种映射的运作方式，以及组相联映射为什么是另外两种映射的结合，谢谢大家的观看。

> 最终，我们探索了2路组相联映射，这是一种平衡直接映射和全相联映射优势的方法。在2路组相联映射中，每个组包含两个缓存行，我们依然采用计数器法来管理缓存替换，但这次计数器的作用范围限制在各自的组内，这就融入了全相联映射的思想，即组内的缓存行可以被任意内存块占用，增强了灵活性。
>
> 按照给定的地址序列，对每个内存地址的处理首先涉及使用其组索引来确定它应该归属的组号。一旦找到相应的组，就在该组内进行标记比对，内存块的写入和更新操作与全相联映射相似，进而定位到所需数据。
>
> 例如，地址2的组序号是1，因此它会被映射到组1的一个空行中。对于地址3，首先确定其属于组序号1的组，然后在组内找到匹配的标记，实现缓存命中。地址8和11的处理逻辑也遵循相同的步骤。
>
> 最后，对于地址13，在组序号为0的组中未找到匹配的标记，此时需要根据组内计数器当前的最大值来决定哪一行应该被替换，以便写入新的数据。
>
> 通过精心设计的动画，我们希望能够使大家直观地理解三种映射方式的运作原理，并揭示组相联映射如何巧妙地结合了直接映射和全相联映射的特点，提供了一种既有效又灵活的缓存管理方案。感谢大家的关注，希望这些讲解对你们有所帮助。
