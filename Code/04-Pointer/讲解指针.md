
## 文稿


> 引言
>
> 我语言的极限便是我世界的极限。——维特根斯坦
>
> 阐述为什么指针难学
>

那一天，人类终于回想起了，曾经被指针支配的恐怖。

可能很多人在学习或者使用指针的时候会遇到各种各样的问题，今天这期视频将不会把重点放在如何学习指针的基础概念上，有cs50等等优秀的入门课，今天将会用更加宏观的观点来看待指针

GPT：

许多学习者在探索指针的世界时可能会遇到一系列挑战。在今天的视频中，我们不打算深入讲述指针的基础知识—那些内容已经由 CS50 等杰出的课程所涵盖。相反，我们将从一个更高层次的视角来审视指针，探讨其在编程领域内的宏大蓝图

> 说明指针的本质和实质，三种抽象角度
>
> 首先给出指针实质，单变量指针，可以介绍存储每个地址的值（存储的地址变为8个地址单元存储的值）
>
> 之后介绍类型的作用。再介绍指针的指针。
>
> 之后进行一定抽象，引出指针是，在编译器的帮助下，用变量名p代替了直接的地址表示。（先给出两个模型，都是地址被矩形包围后指向内存，再将地址消失，之后引入后面的内容）
>
> 再引出进一步抽象，在数据结构里的指针都已经抹去了地址的概念，专注于数据结构的逻辑和操作
>

指针是一种保存变量地址的变量，这句话来自于C语言圣经——C程序设计语言，接下去我们就来将其进行具体阐释。对于C语言里的变量，都有名字、所在地址和对应的值，例如这是一个基础的整形变量，名字是a，表示四个字节的地址，其值是一个整形数。而指针同样如此，具有变量名、表示八个字节的地址，和对应的值。实际上的值是这样被存储在每个地址里的，编译器会帮助将其进行拼接。而指针的值，就是其他变量的地址。在这里需要注意的是，整形变量对应的是四字节，那整形的指针为什么是八字节了呢？



GPT：在 C 语言中，指针被定义为“指向变量地址的变量”，这是从《C程序设计语言》—被广泛认为是 C 语言的经典文献—中提取的概念。接下来，让我们深入探讨这个定义。在 C 语言的世界里，每个变量都拥有自己的名称、地址以及相应的值。以一个基本的整型变量为例，假设其名称为 `a`，它占据了四个字节的内存空间，其中存储的是一个整数值。

指针变量与此相似，也有自己的名称和对应的值，但它所指向的是地址。一个指针变量存储的是另一个变量的内存地址。编译器在这里扮演着关键角色，它负责将分散在各个内存地址中的信息整合起来。现在，您可能会有疑问：为何一个整型变量占用四个字节，而一个指向整型的指针却占用八个字节呢？



我们来看一个指针和数组的情况，其中是有两个值的整形数组，数组的每个元素都有其对应的地址，此时指针指向的是数组开头的元素，而如果要访问第二个元素，我们通常会使用指针加1，而其本质则是对原来的地址加上了四个字节的偏移。同样，我们再来看一下双精度浮点型，其占据八个字节，同样指针指向数组的第一个元素，而使用指针加1访问第二个元素，其本质就是对地址加上了八个字节的偏移。因此我们能够得知，指针的大小与指针的类型无关，而指针的类型会决定地址的偏移量。

GPT：让我们探究指针在操作数组时的行为。假设我们有一个包含两个整数的数组。数组中的每个元素都占据一块内存，并且拥有一个独特的地址。一个指针变量可以被赋值为指向数组的第一个元素的地址。现在，如果我们希望访问数组的第二个元素，我们通常会对指针执行加一操作。在底层，这实际上是在原始地址上增加了四个字节的偏移—这正是一个整型元素的大小。

现在，让我们以双精度浮点数数组为例。每个双精度浮点数占据八个字节。当我们对指向这样一个数组的指针加一时，我们实际上在地址上增加了八个字节的偏移，因此可以访问数组的下一个元素。

通过这些例子，我们可以看出，尽管指针本身的大小是固定的，但它所指向的类型确实决定了通过指针加一进行访问时的地址偏移量。在 64 位系统中，无论指向整数、双精度浮点数，或任何其他类型，指针的大小都是统一的，但是指针的类型会告诉编译器需要跳过多少字节来访问下一个元素。





接着我们回到最一开始的模型，此时我们再来看一下令很多人头疼的指针的指针。其实指针的指针也是一样的原理，只不过其值是另一个指针的地址值，而通过这样的方式就能够访问到原来的变量。此时让我们更进一步，这是一个地址模型，左边是对应的地址，而指针的设计将这个地址抽象为了变量，从这个角度来看，也不难理解为什么很多人会将指针说成是地址。在一定的抽象程度上，指针是地址会有助于我们理解，此时指针的指针也就能这样进行表示。指针还能够进行进一步的抽象，那便是在数据结构中的指针，此时我们不再关心地址细节。很多时候关于指针的争论，是因为大家站在了不同的抽象程度上。

GPT：

让我们回顾最初讨论的内存模型，进一步探讨那些令许多人感到困惑的概念—指针的指针。实际上，指针的指针遵循相同的基本原理：它是一个变量，其值为另一个指针的地址。这样一来，我们便能通过一级指针追踪到原始变量的位置。

深入到地址模型中，我们可以看到，每个内存地址旁边都有对应的数据。指针的妙处在于它把这些地址转换为了我们可以操作的变量。从某种意义上来说，可以将指针视为地址的另一种表现形式。在这种抽象层次上，将指针等同于地址有助于我们的理解，因此，二级指针也可以类似地被表示出来。

然而，指针的概念不止于此。在数据结构的领域中，指针被进一步抽象化。在这个层面，我们不再专注于内存地址的具体细节，而是关注数据的逻辑结构和它们之间的关系。

经常出现关于指针的辩论，很大程度上是因为不同的人在讨论指针时所处的抽象层次不同。一些人可能在谈论具体的内存地址，而其他人可能在讨论数据结构或算法中的抽象概念。理解这些不同的视角，有助于我们更全面地理解指针，并有效地在各种编程情境中应用它们。



> 从物理内存到指针
>
> 目前想法是两段不同指令集的汇编变为C代码
>

ARM架构

```assembly
// pointer.c:2:     int a = 1000;
	mov	w0, 1000
	str	w0, [sp, 28]
// pointer.c:3:     int *p = &a;
	add	x0, sp, 28
	str	x0, [sp, 32]
```

RISC-V架构

```assembly
// pointer.c:2:     int a = 1000;
	li	a5,1000
	sw	a5,-28(s0)
// pointer.c:3:     int *p = &a;
	addi	a5,s0,-28
	sd	a5,-24(s0)
```

接着我们从物理内存开始，看看指针到底在哪里。物理内存对应着物理地址，之后通过操作系统会讲物理内存虚拟化，称为虚拟内存，对应的在这里统称虚拟地址。接着，在编译器的帮助下，我们来看一下汇编语言里的地址表示。这是一段典型的汇编代码，看不懂很正常，只需要明白汇编语言由指令、寄存器和立即数，而通过这样的符号就能够进行内存操作，由此可见在汇编语言层面是直接对内存进行操作的。在不同的架构机器上，汇编语言存在一定的区别，而这两个不同的汇编代码都来自同一个C语言代码，我们可以看到，在汇编时，C语言的类型和变量都消失不见了，指针仅仅是编译器帮助下的C语言语法。通过层层的抽象，我们就能明白指针处于什么样的位置。此时我们再来看一下Java语言，在java中对地址的抽象是引用，但和指针不同的是，java虚拟机会完全接管内存地址的操作。

GPT：

让我们从物理层面开始探索，以便揭示指针在整个体系中的定位。物理内存由实实在在的物理地址标识，这些是硬件直接使用的地址。然而，操作系统并不直接暴露物理内存给我们，而是将其虚拟化。这就是我们所称的虚拟内存，这一层次中我们操作的是虚拟地址。

接下来，我们借助编译器的力量，深入了解汇编语言中的地址是如何表示的。汇编代码由指令、寄存器和立即数组成，它允许我们直接与内存互动，这是一种非常底层的操作方式。即使这段代码看起来可能令人生畏，它揭示了一个关键点：在汇编语言的层次上，我们是在与内存直接对话。

考虑到不同的硬件架构，汇编语言会有所不同。即使是源自同一个 C 语言代码的汇编代码，在不同的架构上也会表现出差异。最引人注目的是，在汇编的过程中，C 语言中定义的类型和变量名消失了，只留下了内存地址的裸露操作。在这一点上，我们可以认为，指针在 C 语言中不过是编译器提供的一种语法结构。

通过这些层层抽象，我们可以清晰地理解指针在整个系统中的位置。而当我们转向 Java 语言，对地址的抽象则被称为引用。与指针不同，Java 的引用不直接暴露内存地址，因为 Java 虚拟机（JVM）会完全接管内存的分配和管理。



与指针不同，加哇的引用不会直接暴露内存地址。因为加哇虚拟机会完全接管内存的分配和管理。

> 说明越界的问题与Java
>

```c
int arr[2] = {0, 1};
int a = 1000;
int x = arr[3]; // 越界访问
```

```java
int[] arr = {0, 1};
int a = 1000;
int x = arr[3]; // 将抛出 ArrayIndexOutOfBoundsException
```

我们可以看一个例子，很明显可以看到这段C语言代码想要访问一个数组外的东西，此处我们使用一个高度简化的内存模型。里面是值，右边是对应的变量，而使用箭头代表指针。对应java的内存模型与之类似，使用箭头代表引用，此外实际访问时java虚拟机会对访问操作进行。此时如果我们希望访问下面的值，对于C语言，即将指针指向改值。如果此时java想要访问，首先会经过JVM的边界检查，此时在边界内，那就可以访问到值。如果此时进行越界访问，c语言的指针依然会向下，并获取到此时的值。而此时java依然会进行边界检查，此时就会抛出异常。我们可以很清楚看到指针操作的可能危险。

GPT：

让我们通过一个实例来探究内存访问的机制。在这个例子中，我们可以明显看到一段 C 语言代码试图访问数组界限之外的内容。为了方便理解，我们将采用一个高度简化的内存模型：左侧是存储的值，右侧是相应的变量名，而指针则通过箭头表示。

与此相似，Java 的内存模型也采用箭头来代表引用。不过，在实际访问之前，Java 虚拟机会介入以执行访问操作。若我们欲访问下方的某个值，C 语言允许我们直接通过指针定位到该值。然而，在 Java 中，每次访问之前，JVM 都会执行严格的边界检查。如果访问在数组界限内，则可以顺利访问到该值；如果尝试越界访问，C 语言中的指针仍然会向下移动，并可能读取到不确定的值。与此同时，Java 会在越界发生时抛出一个异常。

通过这个例子，我们可以清楚地看到直接操作指针可能带来的风险，以及 Java 通过虚拟机提供的安全保障。

> 结尾
>
> 没有银弹，应用的领域和学习的需求不同

最后，对于计算机硬件的世界，通过编译器，C语言被设计了出来，而指针则与硬件世界相连，这也是初学者会觉得C语言的指针很难。C的诞生是为了写操作系统，当时的先驱们都对cpu、内存、I/O和汇编有着深刻的认识，因此对于他们而言指针就很自然。

在计算机硬件的深奥世界中，在编译器的帮助下，思衣语言被巧妙设计出来，简洁优雅但又充满危险。指针就像是调查兵团，引领着我们去了解计算机硬件。

以一个计科专业普通学生的视角，入门编程语言，python或许是更好的选择，从近几年mit等高校改为一开始就教python就能看出来。而对于C，则是为我们通往硬件世界的钥匙。

GPT：

在计算机硬件的深奥世界中，C 语言作为一座桥梁被编译器构建而成，它将我们紧密地与硬件的内核相连。正是这个原因，许多初学者感到 C 语言中的指针概念非常难以理解。毕竟，C 语言的诞生初衷是用来编写操作系统的，而那个时代的开发者们对 CPU、内存、I/O 及汇编语言都有深入的了解。对他们来说，指针的概念是直观且自然的。

从当代计算机科学专业的普通学生的角度来看，Python 可能是更佳的编程语言入门选择。这一点从 MIT 等顶尖大学近年来选择 Python 作为入门教学语言便可见一斑。然而，对于那些渴望深入探索计算机底层世界的人来说，C 语言无疑是打开硬件大门的关键。

---

## 设计思路

物理内存是一个~~一行八列的~~矩形，而通过操作系统（弯角矩形），变为了虚拟内存，打算给出两个平行的和物理内存一样大的矩形，代表着对于每个进程都认为自己独占物理内存，左边的一个往上是汇编语言（圆形里面），左边也是一个弯角矩形的代表编译器，负责将汇编转为机器码。

之后将画面其他部分淡去，留下左边的虚拟地址和汇编，给出汇编中的指令和寄存器，再给出一个C语言指针对应的汇编代码，最后将汇编变为了C语言（圆形里面），希望说明指针是编译器帮助下的只在C语言语法层面存在的概念。

之后给出完整的指针描述图（两种抽象），说明本质和实质。

总结part：之后给出两个同心圆，外边的代表计算机硬件世界，里边的代表C语言语法，被编译器这堵墙包围着，而指针则是两者间的桥梁，代表着对硬件世界的探索。但也带来了挑战。

并之后介绍引用的概念，说明C++解决的策略。（废弃）

然后回到架构图，右边的虚拟内存上面出现一个大的圆角矩形，外圈是虚线，代表了JVM，里面的圆代表java语言，说明内存的概念被JVM处理了。

然后给出左右两边的内存表示，左边是C语言处理越界，右边是java处理越界，说明两者的区别。

到此视频进行最后总结。

---

## 简介

之前评论有人提到指针，因此就做了这一期。自认为市面上已经有很多出色的指针讲解视频，自己也没能力做到解释得更好，就采用了这样的形式来呈现自己的学习和思考。



代码实现花费30h，配音剪辑花费5h。



配音使用【AI星瞳】在线语音合成（Bert-Vits2）

作者：Xz乔希 https://space.bilibili.com/5859321

声音归属：星瞳_Official https://space.bilibili.com/401315430



视频动画使用ManimGL v1.6.1 https://github.com/3b1b/manim

视频源代码地址：https://github.com/ZDaneel/MyManimCode

参考

《C程序设计语言》

《深入理解Java虚拟机》

《UNIX编程艺术》

